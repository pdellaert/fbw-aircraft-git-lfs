use crate::flight_warning::runtime::audio::{
    AutoCallOut, IntermediateCallout, SoundFile, SyntheticVoice,
};
use crate::flight_warning::runtime::warnings::{
    FlightPhases, WarningActivation, WarningConfiguration, WarningType, WarningVisitor,
};
use fxhash::{FxHashMap, FxHashSet};
use std::hash::Hash;
use std::ops::Deref;
use std::time::Duration;
use systems::flight_warning::warnings::WarningCode;
use systems::warning_code;
use uom::si::f64::Length;

pub(super) trait A320FwcMonitorParameters {
    fn visit_warnings(&self, visitor: &mut impl WarningVisitor);
    fn flight_phases(&self) -> [bool; 10];
    fn flight_phase_inhib_ovrd(&self) -> bool;
    fn mw_cancel_pulse_up(&self) -> bool;
    fn mc_cancel_pulse_up(&self) -> bool;
    fn radio_height(&self) -> Length;
    fn intermediate_call_out(&self) -> bool;
    fn auto_call_out_inhib(&self) -> bool;
    fn retard_inhibition(&self) -> bool;
}

struct WarningActivationActiveVisitor {
    warnings: Vec<WarningCode>,
    audio: Vec<WarningCode>,
}

impl WarningActivationActiveVisitor {
    pub(super) fn new(capacity: usize) -> Self {
        Self {
            warnings: Vec::with_capacity(capacity),
            audio: Vec::with_capacity(capacity),
        }
    }

    fn warnings(&self) -> Vec<WarningCode> {
        self.warnings.clone()
    }

    fn audio(&self) -> Vec<WarningCode> {
        self.audio.clone()
    }
}

impl WarningVisitor for WarningActivationActiveVisitor {
    fn visit(&mut self, warning: &(impl WarningConfiguration + WarningActivation)) {
        let warning_code = warning.warning_code();
        if warning.warning() {
            self.warnings.push(warning_code);
        }
        if warning.audio() {
            self.audio.push(warning_code);
        }
    }
}

#[derive(Default, Debug)]
pub(super) struct A320FwcMonitorFeedback {
    minimum_generated: bool,
    hundred_above_generated: bool,
    priority_left_generated: bool,
    priority_right_generated: bool,
    auto_call_out_generated: bool,
    inter_audio: bool,
}

impl A320FwcMonitorFeedback {
    /// This signal is generated by the Monitor and indicates that "minimum" is currently playing.
    pub(super) fn minimum_generated(&self) -> bool {
        self.minimum_generated
    }

    /// This signal is generated by the Monitor and indicates that "hundred above" is currently
    /// playing.
    pub(super) fn hundred_above_generated(&self) -> bool {
        self.hundred_above_generated
    }

    pub(super) fn priority_left_generated(&self) -> bool {
        self.priority_left_generated
    }

    pub(super) fn priority_right_generated(&self) -> bool {
        self.priority_right_generated
    }

    /// This signal is generated by the Monitor and indicates that an altitude callout just
    /// started playing. It is a feedback signal that can be used by the warning logic to determine
    /// when too much time has passed since the last altitude callout.
    pub(super) fn auto_call_out_generated(&self) -> bool {
        self.auto_call_out_generated
    }

    /// This signal indicates that an intermediate altitude callout just completed.
    pub(super) fn inter_audio(&self) -> bool {
        self.inter_audio
    }
}

struct DurationCounter<T: Eq + Hash + Copy> {
    durations: FxHashMap<T, Duration>,
}

impl<T: Eq + Hash + Copy> DurationCounter<T> {
    fn update(&mut self, active: &[T], delta: Duration) -> Vec<(T, Duration)> {
        let previously_tracked: Vec<T> = self.durations.keys().cloned().collect();
        for member in previously_tracked.iter() {
            // remove all members that are no longer active to reset their confirmation
            // delay the next time they trigger
            if !active.contains(member) {
                self.durations.remove(member);
            }
        }

        let mut durations: Vec<(T, Duration)> = Vec::with_capacity(active.len());

        for member in active.iter() {
            let duration = self
                .durations
                .entry(*member)
                .and_modify(|d| *d += delta)
                .or_insert(Duration::ZERO);
            durations.push((*member, *duration));
        }

        durations
    }
}

impl<K: Eq + Hash + Copy> Default for DurationCounter<K> {
    fn default() -> Self {
        Self {
            durations: FxHashMap::default(),
        }
    }
}

struct LatchSet<T: Eq + Hash + Copy> {
    latches: FxHashSet<T>,
}

impl<T: Eq + Hash + Copy> LatchSet<T> {
    fn set<C: Fn(T) -> bool>(&mut self, set: &[T], can_set: C) -> Vec<T> {
        let previously_tracked: Vec<T> = self.latches.iter().cloned().collect();
        for member in previously_tracked.iter() {
            // remove all members that are no longer active to reset their confirmation
            if !set.contains(member) {
                self.latches.remove(member);
            }
        }

        let mut latched: Vec<T> = Vec::with_capacity(set.len());

        for member in set.iter() {
            if can_set(*member) {
                self.latches.insert(*member);
            }
            if self.latches.contains(member) {
                latched.push(*member);
            }
        }

        latched
    }
}

impl<K: Eq + Hash + Copy> Default for LatchSet<K> {
    fn default() -> Self {
        Self {
            latches: FxHashSet::default(),
        }
    }
}

/// This struct represents the Flight Warning Computer monitor, which is the component that is
/// ultimately responsible for displaying warnings and emitting sounds. As input it considers the
/// activated warnings and crew actions to decide which warnings should be currently suppressed,
/// cleared, recalled, and how to prioritize the active warnings.
#[derive(Default)]
pub(super) struct A320FwcMonitor {
    warning_configuration: Option<FxHashMap<WarningCode, WarningConfigurationStruct>>,

    audio_durations: DurationCounter<WarningCode>,
    video_durations: DurationCounter<WarningCode>,

    audio_flight_phase_latch: LatchSet<WarningCode>,
    video_flight_phase_latch: LatchSet<WarningCode>,

    flight_phase_inhib_ovrd: bool,
    to_memo: bool,
    ldg_memo: bool,
    to_inhibit_memo: bool,
    ldg_inhibit_memo: bool,

    audio_cancelled: FxHashSet<WarningCode>,
    video_cleared: FxHashSet<WarningCode>,

    minimum_generated: bool,
    hundred_above_generated: bool,
    priority_left_generated: bool,
    priority_right_generated: bool,
    auto_call_out_generated: bool,
    inter_audio_deferred: bool,

    current_synthetic_voice: Option<Box<dyn SyntheticVoice>>,
    next_synthetic_voice: Option<Box<dyn SyntheticVoice>>,

    current_audio: Option<SoundFile>,
}

impl A320FwcMonitor {
    /// This method performs the main update step of the FWCs monitor. It's primary goal is to
    /// filter the active warnings down for eventual presentation to the pilots. This includes:
    /// filtering out spurious warnings, filtering out warnings that should be inhibited in the
    /// current flight phase and filtering out warnings that have been cancelled or cleared
    /// by the pilots.
    pub(super) fn update(
        &mut self,
        delta: Duration,
        parameters: &impl A320FwcMonitorParameters,
        synthetic_voice_ready: bool,
    ) {
        self.flight_phase_inhib_ovrd = parameters.flight_phase_inhib_ovrd();

        let warning_configuration = self.warning_configuration.get_or_insert_with(|| {
            let mut visitor = WarningSetupVisitor::default();
            parameters.visit_warnings(&mut visitor);
            visitor.warning_setup()
        });

        let mut visitor = WarningActivationActiveVisitor::new(warning_configuration.len());
        parameters.visit_warnings(&mut visitor);

        let audio_logic = visitor.audio();
        let video_logic = visitor.warnings();

        // First, filter the warning logic by activation delay. This prevents spurious activations.

        // This closure filters a single tuple of Warning Code -> Duration down to Some(WarningCode)
        // if the duration has reached or exceeded the required confirmation delay, or None if it
        // has not. It is used by the filter_map() call below to filter down the video and audio
        // durations to the WarningCodes that have been seen long enough to be confirmed.
        let filter_map_by_delay = |&(key, val): &(WarningCode, Duration)| -> Option<WarningCode> {
            let config = warning_configuration.get(&key);
            let confirmation_delay = config
                .map(|c| {
                    if c.warning_type.bypass_activation_delay() {
                        Duration::ZERO
                    } else {
                        c.confirmation_delay
                    }
                })
                .unwrap_or(Duration::ZERO);
            if val >= confirmation_delay {
                Some(key)
            } else {
                None
            }
        };

        let audio_after_delay: Vec<WarningCode> = self
            .audio_durations
            .update(&audio_logic, delta)
            .iter()
            .filter_map(filter_map_by_delay)
            .collect();
        let video_after_delay: Vec<WarningCode> = self
            .video_durations
            .update(&video_logic, delta)
            .iter()
            .filter_map(filter_map_by_delay)
            .collect();

        // Then, filter warnings so that they only appear if they've either already been seen or are
        // allowed to appear in the current flight phase.
        let flight_phases = parameters.flight_phases();

        // This closure returns whether a given warning code is not inhibited by the current flight
        // phase and can appear.
        let can_appear = |wc| {
            let config = warning_configuration.get(&wc);
            config
                .map(|c| {
                    // For all Flight Phases, either the flight phase is not active, or the warning
                    // is explicitly enabled for this flight phase
                    flight_phases.iter().enumerate().all(|(i, active)| {
                        !*active || c.enabled_flight_phases.contains((i + 1) as u8)
                    })
                })
                .unwrap_or(false)
        };

        let audio_after_flight_phase = self
            .audio_flight_phase_latch
            .set(&audio_after_delay, can_appear);
        let video_after_flight_phase = self
            .video_flight_phase_latch
            .set(&video_after_delay, can_appear);

        // Finally, filter out the warnings that have been explicitly cancelled by the crew
        let audio_after_cancelled = self.filter_audio_by_cancelled(
            &audio_after_flight_phase,
            parameters.mw_cancel_pulse_up(),
            parameters.mc_cancel_pulse_up(),
        );
        let video_after_cancelled = self.filter_video_by_cancelled(&video_after_flight_phase);

        self.update_synthetic_voice(parameters, &audio_after_cancelled, synthetic_voice_ready);
        self.update_sounds(&audio_after_cancelled);
        self.update_video(&video_after_cancelled);
    }

    fn config_for_warning(&self, code: WarningCode) -> Option<WarningConfigurationStruct> {
        if let Some(config) = &self.warning_configuration {
            config.get(&code).cloned()
        } else {
            None
        }
    }

    /// This method updates the synthetic voice call outs.
    /// Examples of these call outs are critical warnings (Stall, Speed, Windshear) and more
    /// informational like altitude callouts (Forty, Thirty, Twenty, Retard).
    /// At every update tick, the monitor will check if the audio subsystem is ready. If it is, it
    /// can queue up a sequence of callouts.
    fn update_synthetic_voice(
        &mut self,
        parameters: &impl A320FwcMonitorParameters,
        warnings: &[WarningCode],
        synthetic_voice_ready: bool,
    ) {
        // reset the callout started pulses
        self.minimum_generated = false;
        self.hundred_above_generated = false;
        self.priority_left_generated = false;
        self.priority_right_generated = false;
        self.auto_call_out_generated = false;
        if synthetic_voice_ready {
            self.inter_audio_deferred = false;
        }

        let mut queue: Vec<Box<dyn SyntheticVoice>> = vec![];

        for warning in warnings.iter() {
            let _config = self.config_for_warning(*warning);
            if let Some(config) = _config {
                if let Some(voice) = config.synthetic_voice {
                    queue.push(Box::new(voice));
                }
            }
        }

        if (queue.first().map_or(true, |v| !v.deref().is_auto_callout()))
            && !self.inter_audio_deferred
            && !parameters.intermediate_call_out()
            && !parameters.auto_call_out_inhib()
            && !parameters.retard_inhibition()
        {
            if let Some(intermediate) = IntermediateCallout::from_height(parameters.radio_height())
            {
                queue.push(Box::new(intermediate));
            }
        }

        let mut iter = queue.into_iter();
        if let Some(first) = iter.next() {
            self.next_synthetic_voice = Some(first);
        }

        if synthetic_voice_ready {
            self.pop_synthetic_voice();
        }

        if self.next_synthetic_voice.is_none() {
            if let Some(second) = iter.next() {
                self.next_synthetic_voice = Some(second);
            }
        }
    }

    fn pop_synthetic_voice(&mut self) {
        if let Some(voice_ptr) = self.next_synthetic_voice.take() {
            let voice = voice_ptr.deref();
            self.minimum_generated = voice.is_minimum();
            self.hundred_above_generated = voice.is_hundred_above();
            self.priority_left_generated = voice.is_priority_left();
            self.priority_right_generated = voice.is_priority_right();
            self.auto_call_out_generated = voice.is_auto_callout();
            self.inter_audio_deferred = voice.is_intermediate_callout();

            self.current_synthetic_voice = Some(voice_ptr);
        }
    }

    fn update_sounds(&mut self, warnings: &[WarningCode]) {
        self.current_audio = None;
        for warning in warnings.iter() {
            if let Some(config) = self.config_for_warning(*warning) {
                if let Some(sound) = config.sound_file {
                    self.current_audio = Some(sound);
                    break;
                }
            }
        }
    }

    fn update_video(&mut self, warnings: &[WarningCode]) {
        // this will be replaced by a proper EWD implementation later
        self.to_memo = warnings.contains(&warning_code!("00", "00", "010"));
        self.ldg_memo = warnings.contains(&warning_code!("00", "00", "020"));
        self.to_inhibit_memo = warnings.contains(&warning_code!("00", "00", "140"));
        self.ldg_inhibit_memo = warnings.contains(&warning_code!("00", "00", "150"));
    }

    fn filter_audio_by_cancelled(
        &mut self,
        warnings: &[WarningCode],
        mut mw_cancel: bool,
        _mc_cancel: bool,
    ) -> Vec<WarningCode> {
        let previously_active: Vec<WarningCode> =
            self.audio_cancelled.clone().into_iter().collect();
        for code in previously_active.iter() {
            if !warnings.contains(code) {
                self.audio_cancelled.remove(code);
            }
        }

        let mut allowed_warnings = Vec::with_capacity(warnings.len());
        for code in warnings.iter() {
            let config = self.config_for_warning(*code).unwrap();
            if config.sound_file.is_none() && config.synthetic_voice.is_none() {
                // ignore warnings that are not audio or synthetic voice
                continue;
            }

            if self.audio_cancelled.contains(code) {
                // ignore cancelled warnings
                continue;
            }

            if config.sound_file.is_some() && mw_cancel {
                self.audio_cancelled.insert(*code);
                mw_cancel = false;
                continue;
            }

            allowed_warnings.push(*code);
        }

        allowed_warnings
    }

    fn filter_video_by_cancelled(&mut self, warnings: &[WarningCode]) -> Vec<WarningCode> {
        let mut allowed_warnings = Vec::with_capacity(warnings.len());
        for code in warnings.iter() {
            if !self.video_cleared.contains(code) {
                allowed_warnings.push(*code);
            }
        }

        allowed_warnings
    }

    pub(super) fn show_to_memo(&self) -> bool {
        self.to_memo
    }

    pub(super) fn show_ldg_memo(&self) -> bool {
        self.ldg_memo
    }

    pub(super) fn show_to_inhibit_memo(&self) -> bool {
        self.to_inhibit_memo
    }

    pub(super) fn show_ldg_inhibit_memo(&self) -> bool {
        self.ldg_inhibit_memo
    }

    pub(super) fn flight_phase_inhibit_override(&self) -> bool {
        self.flight_phase_inhib_ovrd
    }

    pub(super) fn sound_file(&mut self) -> Option<SoundFile> {
        self.current_audio
    }

    pub(super) fn take_synthetic_voice(&mut self) -> Option<Box<dyn SyntheticVoice>> {
        self.current_synthetic_voice.take()
    }

    pub(super) fn get_feedback(&self, synthetic_voice_ready: bool) -> A320FwcMonitorFeedback {
        A320FwcMonitorFeedback {
            minimum_generated: self.minimum_generated,
            hundred_above_generated: self.hundred_above_generated,
            priority_left_generated: self.priority_left_generated,
            priority_right_generated: self.priority_right_generated,
            auto_call_out_generated: self.auto_call_out_generated,
            inter_audio: synthetic_voice_ready && self.inter_audio_deferred,
        }
    }
}

#[derive(Clone)]
struct WarningConfigurationStruct {
    enabled_flight_phases: FlightPhases,
    sound_file: Option<SoundFile>,
    synthetic_voice: Option<AutoCallOut>,
    confirmation_delay: Duration,
    warning_type: WarningType,
}

/// A visitor to memorize the different warnings that are set up.
#[derive(Default)]
struct WarningSetupVisitor {
    map: FxHashMap<WarningCode, WarningConfigurationStruct>,
}

impl WarningSetupVisitor {
    fn warning_setup(&self) -> FxHashMap<WarningCode, WarningConfigurationStruct> {
        self.map.clone()
    }
}

impl WarningVisitor for WarningSetupVisitor {
    fn visit(&mut self, warning: &(impl WarningConfiguration + WarningActivation)) {
        let warning_code = warning.warning_code();

        self.map.insert(
            warning_code,
            WarningConfigurationStruct {
                enabled_flight_phases: warning.flight_phases(),
                sound_file: warning.audio_file(),
                synthetic_voice: warning.synthetic_voice(),
                confirmation_delay: warning.confirmation_delay(),
                warning_type: warning.warning_type(),
            },
        );
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;

    mod monitor_tests {
        use super::*;
        use crate::flight_warning::runtime::audio::{AudioData, VoiceFile};
        use crate::flight_warning::runtime::warnings::{WarningActivation, WarningConfiguration};
        use uom::si::length::foot;

        struct SimulatedWarning {
            audio: bool,
            warning: bool,
            warning_type: WarningType,
            warning_code: WarningCode,
            flight_phases: FlightPhases,
            auto_call_out: Option<AutoCallOut>,
        }

        impl SimulatedWarning {
            fn callout(auto_call_out: AutoCallOut) -> Self {
                Self {
                    audio: false,
                    warning: false,
                    warning_type: WarningType::AutoCallOut,
                    warning_code: warning_code!("99", "00", "000"),
                    flight_phases: FlightPhases::all(),
                    auto_call_out: Some(auto_call_out),
                }
            }

            fn into_active(mut self) -> Self {
                self.audio = true;
                self.warning = true;
                self
            }
        }

        impl Default for SimulatedWarning {
            fn default() -> Self {
                Self {
                    audio: false,
                    warning: false,
                    warning_type: WarningType::IndependentFailure,
                    warning_code: warning_code!("99", "00", "000"),
                    flight_phases: FlightPhases::all(),
                    auto_call_out: None,
                }
            }
        }

        impl WarningConfiguration for SimulatedWarning {
            fn warning_type(&self) -> WarningType {
                self.warning_type
            }

            fn warning_code(&self) -> WarningCode {
                self.warning_code
            }

            fn flight_phases(&self) -> FlightPhases {
                self.flight_phases.clone()
            }

            fn synthetic_voice(&self) -> Option<AutoCallOut> {
                self.auto_call_out
            }
        }

        impl WarningActivation for SimulatedWarning {
            fn warning(&self) -> bool {
                self.warning
            }

            fn audio(&self) -> bool {
                self.audio
            }
        }

        #[derive(Default)]
        struct MonitorTestParameters {
            warnings: Vec<SimulatedWarning>,
            flight_phases: [bool; 10],
            flight_phase_inhib_ovrd: bool,
            mw_cancel_pulse_up: bool,
            mc_cancel_pulse_up: bool,
            radio_height: Length,
            intermediate_callout: bool,
            auto_call_out_inhib: bool,
            retard_inhibition: bool,
        }

        impl MonitorTestParameters {
            fn ready_for_intermediate(radio_height: Length) -> Self {
                Self {
                    warnings: vec![],
                    flight_phases: Default::default(),
                    flight_phase_inhib_ovrd: false,
                    mw_cancel_pulse_up: false,
                    mc_cancel_pulse_up: false,
                    radio_height,
                    intermediate_callout: false,
                    auto_call_out_inhib: false,
                    retard_inhibition: false,
                }
            }

            fn add_warning(mut self, warning: SimulatedWarning) -> Self {
                debug_assert!(
                    !self
                        .warnings
                        .iter()
                        .any(|old_warning| old_warning.warning_code == warning.warning_code),
                    "You cannot add two warnings with the same warning code"
                );
                self.warnings.push(warning);
                self
            }
        }

        impl A320FwcMonitorParameters for MonitorTestParameters {
            fn visit_warnings(&self, visitor: &mut impl WarningVisitor) {
                for x in self.warnings.iter() {
                    visitor.visit(x);
                }
            }

            fn flight_phases(&self) -> [bool; 10] {
                self.flight_phases
            }

            fn flight_phase_inhib_ovrd(&self) -> bool {
                self.flight_phase_inhib_ovrd
            }

            fn mw_cancel_pulse_up(&self) -> bool {
                self.mw_cancel_pulse_up
            }

            fn mc_cancel_pulse_up(&self) -> bool {
                self.mc_cancel_pulse_up
            }

            fn radio_height(&self) -> Length {
                self.radio_height
            }

            fn intermediate_call_out(&self) -> bool {
                self.intermediate_callout
            }

            fn auto_call_out_inhib(&self) -> bool {
                self.auto_call_out_inhib
            }

            fn retard_inhibition(&self) -> bool {
                self.retard_inhibition
            }
        }

        #[test]
        fn emits_no_sound_when_no_sound_requeuted() {
            let mut monitor = A320FwcMonitor::default();
            monitor.update(
                Duration::from_millis(100),
                &MonitorTestParameters::default(),
                false,
            );
            assert!(monitor.sound_file().is_none());
            assert!(monitor.take_synthetic_voice().is_none())
        }

        #[test]
        fn plays_a_single_callout() {
            let mut monitor = A320FwcMonitor::default();
            monitor.update(
                Duration::from_millis(100),
                &MonitorTestParameters::default().add_warning(
                    SimulatedWarning::callout(AutoCallOut::TwoThousandFiveHundredFt).into_active(),
                ),
                true,
            );
            assert_eq!(
                *monitor.take_synthetic_voice().unwrap().deref(),
                AutoCallOut::TwoThousandFiveHundredFt
            );
        }

        #[test]
        fn plays_an_intermediate_callout() {
            let mut monitor = A320FwcMonitor::default();
            monitor.update(
                Duration::from_millis(100),
                &MonitorTestParameters::ready_for_intermediate(Length::new::<foot>(72.)),
                true,
            );
            assert_eq!(
                *monitor.take_synthetic_voice().unwrap().deref(),
                IntermediateCallout::from_height(Length::new::<foot>(72.)).unwrap(),
            );
        }

        #[test]
        fn retard_test() {
            let mut monitor = A320FwcMonitor::default();
            monitor.update(
                Duration::from_millis(100),
                &MonitorTestParameters::default()
                    .add_warning(SimulatedWarning::callout(AutoCallOut::Retard).into_active()),
                true,
            );
            assert_eq!(
                *monitor.take_synthetic_voice().unwrap().deref(),
                AutoCallOut::Retard
            );
            let audio_data: AudioData = VoiceFile::Retard.into();
            let length_of_retard = audio_data.duration().unwrap();
            monitor.update(
                length_of_retard - Duration::from_millis(1),
                &MonitorTestParameters::default(),
                true,
            );
        }

        #[test]
        fn can_emit_intermediate_callouts() {}

        #[test]
        fn buffers_a_second_callout() {}
    }
}
